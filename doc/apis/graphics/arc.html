<!DOCTYPE html>
<html lang="zh-cn">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="../../libs/easycss-1.3.1.min.css">
    <link rel="stylesheet" href="../../libs/prettify.css">
    <link rel="stylesheet" href="../../doc.css">
    <script src="../../libs/prettify.js"></script>
</head>

<body onload="prettyPrint()">
    <header>
        圆弧 arc
    </header>
    <h2>
        Canvas2D
    </h2>
    <p>
        这里和上一节对比，就是把method换成了arc，我们只说明上面没有说明的部分。
    </p>
    <pre class='prettyprint lang-js'>var arc=$$.canvas.arc('canvas')
    // 设置弧圆心
    .setCenter(cx, cy)
    // 设置内外半径
    .setRadius(r1, r2)
    // 分别设置开始和结尾是否需要使用圆弧闭合，默认直线闭合
    .lineCap(boolean, boolean);
    </pre>
    <p>
        上面多了二个配置语句，因为画弧形，你需要确定弧形的圆心和弧形有多宽，宽由内外半径差确定。另外，这二个方法都不是必须的，都有缺省值。返回绘图对象。
    </p>
    <pre class='prettyprint lang-js'>arc(beginA, rotateA[, r1, r2]).fill();</pre>
    <p>
        最后绘制图形，传入弧形的起始弧度和终止弧度，另外内外半径是可选的，不传递就使用之前设置的或默认的，传递就使用传递的，不过不会被内部记录。返回画笔。
    </p>
    <p class="warn">
        由于绘制的时候不知道需要的是轮廓线还是图形，因此最后需要自行调用fill或stroke方法，别的也一样。
    </p>
    <h2>
        SVG
    </h2>
    <pre class='prettyprint lang-js'>var arc=$$.svg.arc()
    // 设置弧圆心
    .setCenter(cx, cy)
    // 设置内外半径
    .setRadius(r1, r2)
    // 分别设置开始和结尾是否需要使用圆弧闭合，默认直线闭合
    .lineCap(boolean, boolean);

// 获取弧形路径
var d=arc(beginA, rotateA[, r1, r2]);</pre>
    <p>
        和canvas方式绘制大致一样，唯一的区别在与，没有画笔和样式的配置，返回的是path标签的d属性的值，因此具体样式的编辑就属于结点对象的事情了：
    </p>
    <pre class='prettyprint lang-js'>$$('path').attr('d', d)
    .css({
        'key':'value',
        ...
    });</pre>
</body>

</html>
