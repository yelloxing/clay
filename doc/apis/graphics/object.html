<!DOCTYPE html>
<html lang="zh-cn">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="../../libs/easycss-1.3.1.min.css">
    <link rel="stylesheet" href="../../libs/prettify.css">
    <link rel="stylesheet" href="../../doc.css">
    <script src="../../libs/prettify.js"></script>
</head>

<body onload="prettyPrint()">
    <header>
        绘图对象
    </header>
    <p>
        由于原始的绘图接口在绘制某些图形的时候并不够方便和高效，这里在此基础上添加一些常用图形绘制接口，是对原生的一种有效加强。
    </p>
    <h2>
        SVG&amp;HTML
    </h2>
    <p>
        结点对象中提供的一系列方法就是为了使用这两种绘图方式而生的，可能你还会借助CSS，比如一棵常规树，使用CSS绘制可能比tree布局更有效。
    </p>
    <p>
        另外，下面对svg绘图进行了加强，但是为了保证灵活性，提供的接口并不能直接绘图，而是返回计算后的路径数据，这会在具体的接口中说明。
    </p>
    <h2>
        Canvas2D
    </h2>
    <pre class='prettyprint lang-js'>var pencil=$$('canvas').painter();</pre>
    <p>
        你依旧可以使用原来的方式获取画笔，不过，我们鼓励你使用上面的方法，当然，不要忘记了图层管理者，可能有时候，还需要配合使用区域管理者。
    </p>
    <p>
        接着，我们还需要额外说明一下使用这种方式进行绘图的统一流程。假设我们现在有一个绘图方法叫method：
    </p>
    <pre class='prettyprint lang-js'>// 获取method对应的绘图对象
var methodObj = $$.canvas.method(selector,{
    //  配置画笔
    "key":"value",
    ......
});
// 使用绘图对象绘图
methodObj(param);</pre>
    <p>
        当获取method对应的绘图对象的时候，可以传递两个参数，分别表示绘图的画笔和画笔的配置。其中selector可以是任意一个合法的选择器（在文档结点对象的基本的结点操作一节中有定义），或者2D画笔，比如在传递上面的pencil的时候。
    </p>
    <p>
        另外，这两个参数都不是必须的，你可以在后续进行配置或修改，比如下面这样：
    </p>
    <pre class='prettyprint lang-js'>methodObj.painter(selector);</pre>
    <p>
        设置绘图目标，selector和上面一样。返回绘图对象。
    </p>
    <pre class='prettyprint lang-js'>methodObj.config({
    "key":"value",
    ......
});</pre>
    <p>
        配置画笔，返回绘图对象。当然，如果你不喜欢json这种方式，直接通过pencil修改也是一样的。
    </p>
</body>

</html>
